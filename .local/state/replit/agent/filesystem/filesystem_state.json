{"file_contents":{"README.md":{"content":"# GestokPro - Sistema de Gestão de Estoque\n\n![GestokPro](https://img.shields.io/badge/GestokPro-v1.0-blue.svg)\n![Python](https://img.shields.io/badge/Python-3.8+-green.svg)\n![Flask](https://img.shields.io/badge/Flask-2.0+-red.svg)\n![PostgreSQL](https://img.shields.io/badge/PostgreSQL-13+-blue.svg)\n\nGestokPro é um sistema completo de gestão de estoque desenvolvido em Flask, projetado para pequenas e médias empresas. O sistema oferece uma interface web moderna para gerenciar catálogos de produtos, controlar níveis de estoque e monitorar métricas de inventário.\n\n## 📋 Índice\n\n- [Características](#-características)\n- [Pré-requisitos](#-pré-requisitos)\n- [Instalação Local](#-instalação-local)\n- [Estrutura do Projeto](#-estrutura-do-projeto)\n- [Entidades do Sistema](#-entidades-do-sistema)\n- [Funcionalidades](#-funcionalidades)\n- [Sistema de Testes de Performance](#-sistema-de-testes-de-performance)\n- [Como Usar](#-como-usar)\n- [Deploy no GitHub](#-deploy-no-github)\n- [API Endpoints](#-api-endpoints)\n- [Contribuição](#-contribuição)\n\n## 🚀 Características\n\n- **Interface Web Moderna**: Interface responsiva com Tailwind CSS\n- **Autenticação de Usuários**: Sistema seguro com Flask-Login\n- **CRUD de Produtos**: Criação, leitura, atualização e exclusão de produtos\n- **Gestão de Estoque**: Controle de quantidades e status de produtos\n- **Dashboard Analytics**: Métricas em tempo real do inventário\n- **Sistema de Performance**: Monitoramento completo de performance\n- **Testes de Estresse**: Sistema avançado de testes automatizados\n- **Relatórios Automáticos**: Geração de relatórios detalhados\n- **Localização**: Sistema totalmente em português brasileiro\n\n## 📋 Pré-requisitos\n\n### Software Necessário\n\n- **Python 3.8+** - Linguagem de programação principal\n- **PostgreSQL 13+** - Banco de dados de produção\n- **Git** - Para controle de versão\n- **Navegador Web Moderno** - Para interface do usuário\n\n### Dependências Python\n\n```txt\nflask>=2.0.0          # Framework web principal\nflask-sqlalchemy      # ORM para banco de dados\nflask-login           # Sistema de autenticação\nflask-wtf             # Formulários e CSRF protection\nwtforms               # Validação de formulários\nwerkzeug              # Utilitários WSGI e segurança\npsycopg2-binary       # Driver PostgreSQL\ngunicorn              # Servidor WSGI para produção\naiohttp               # Cliente HTTP para testes\n```\n\n## 💻 Instalação Local\n\n### 1. Clone o Repositório\n\n```bash\ngit clone https://github.com/seu-usuario/gestokpro.git\ncd gestokpro\n```\n\n### 2. Criar Ambiente Virtual\n\n```bash\n# Linux/Mac\npython3 -m venv venv\nsource venv/bin/activate\n\n# Windows\npython -m venv venv\nvenv\\Scripts\\activate\n```\n\n### 3. Instalar Dependências\n\n```bash\npip install -r requirements.txt\n```\n\n### 4. Configurar Banco de Dados\n\n```bash\n# Instalar PostgreSQL (Ubuntu/Debian)\nsudo apt update\nsudo apt install postgresql postgresql-contrib\n\n# Criar banco de dados\nsudo -u postgres createdb gestokpro\n```\n\n### 5. Configurar Variáveis de Ambiente\n\nCrie um arquivo `.env`:\n\n```bash\nDATABASE_URL=postgresql://usuario:senha@localhost/gestokpro\nSESSION_SECRET=sua-chave-secreta-super-segura\n```\n\n### 6. Inicializar Banco de Dados\n\n```bash\npython init_db.py\n```\n\n### 7. Executar Aplicação\n\n```bash\n# Desenvolvimento\npython app.py\n\n# Produção\ngunicorn --bind 0.0.0.0:5000 main:app\n```\n\nAcesse: `http://localhost:5000`\n\n**Login padrão:**\n- Email: `admin@gestokpro.com`\n- Senha: `admin`\n\n## 📁 Estrutura do Projeto\n\n```\ngestokpro/\n├── app.py                          # Aplicação Flask principal\n├── main.py                         # Ponto de entrada WSGI\n├── models.py                       # Modelos de dados SQLAlchemy\n├── forms.py                        # Formulários WTForms\n├── init_db.py                      # Script de inicialização do BD\n├── requirements.txt                # Dependências Python\n├── README.md                       # Documentação (este arquivo)\n├── replit.md                       # Arquitetura e preferências\n├──\n├── templates/                      # Templates Jinja2\n│   ├── base.html                   # Template base\n│   ├── login.html                  # Página de login\n│   ├── dashboard.html              # Dashboard principal\n│   ├── produtos.html               # Listagem de produtos\n│   ├── produto_form.html           # Formulário de produtos\n│   └── teste_estresse.html         # Interface de testes\n├──\n├── static/                         # Arquivos estáticos\n│   ├── css/                        # Estilos customizados\n│   ├── js/                         # Scripts JavaScript\n│   └── images/                     # Imagens e ícones\n├──\n├── instance/                       # Configurações de instância\n├──\n├── stress_tests/                   # Sistema de testes\n│   ├── test_stress.py              # Teste básico\n│   ├── advanced_stress_test.py     # Teste avançado\n│   ├── run_stress_test.py          # Teste rápido\n│   └── test_menu.py                # Menu interativo\n└──\n└── reports/                        # Relatórios de teste\n    ├── stress_test_report_*.md     # Relatórios automáticos\n    └── advanced_stress_report_*.md # Relatórios detalhados\n```\n\n### Descrição dos Arquivos Principais\n\n#### `app.py` - Aplicação Principal\n- **Propósito**: Núcleo da aplicação Flask\n- **Funcionalidades**:\n  - Configuração da aplicação e banco de dados\n  - Definição de todas as rotas (endpoints)\n  - Sistema de autenticação e autorização\n  - Middleware de monitoramento de performance\n  - Integração com sistema de testes de estresse\n\n#### `models.py` - Modelos de Dados\n- **Propósito**: Define a estrutura do banco de dados\n- **Entidades**:\n  - `Usuario`: Contas de usuários do sistema\n  - `Produto`: Catálogo de produtos do estoque\n- **Funcionalidades**:\n  - Relacionamentos entre tabelas\n  - Métodos de negócio (cálculos de estoque)\n  - Validações de dados\n\n#### `forms.py` - Formulários Web\n- **Propósito**: Validação e renderização de formulários\n- **Formulários**:\n  - `LoginForm`: Autenticação de usuários\n  - `ProdutoForm`: Cadastro e edição de produtos\n- **Características**:\n  - Validações automáticas\n  - Proteção CSRF\n  - Mensagens de erro personalizadas\n\n#### `init_db.py` - Inicialização do Banco\n- **Propósito**: Script para configurar o banco de dados\n- **Funcionalidades**:\n  - Criação de tabelas\n  - Inserção de dados iniciais\n  - Criação de usuário administrador\n  - População com produtos de exemplo\n\n## 🗃️ Entidades do Sistema\n\n### 👤 Usuario (Usuário)\nEntidade responsável pelo gerenciamento de contas de usuários.\n\n**Campos:**\n- `id`: Identificador único (Primary Key)\n- `email`: Email do usuário (único, obrigatório)\n- `senha_hash`: Senha criptografada com Werkzeug\n- `admin`: Flag para permissões administrativas\n- `data_criacao`: Timestamp de criação da conta\n\n**Métodos:**\n- `verificar_senha(senha)`: Valida senha fornecida\n- `is_admin()`: Verifica se usuário é administrador\n\n### 📦 Produto (Produto)\nEntidade central para gestão do catálogo de produtos.\n\n**Campos:**\n- `id`: Identificador único (Primary Key)\n- `sku`: Código único do produto (obrigatório)\n- `nome`: Nome do produto (obrigatório)\n- `descricao`: Descrição detalhada\n- `quantidade`: Estoque atual\n- `preco_custo`: Custo de aquisição\n- `preco_venda`: Preço de venda\n- `categoria`: Categoria do produto\n- `data_criacao`: Data de cadastro\n- `data_atualizacao`: Última modificação\n\n**Métodos de Negócio:**\n- `get_status_estoque()`: Retorna status baseado na quantidade\n  - \"Crítico\" (< 10 unidades)\n  - \"Baixo\" (10-50 unidades)  \n  - \"Normal\" (> 50 unidades)\n- `calcular_margem()`: Calcula margem de lucro\n- `valor_total_estoque()`: Valor total em estoque\n\n## ⚡ Funcionalidades\n\n### 🔐 Sistema de Autenticação\n- **Login/Logout**: Sessões seguras com Flask-Login\n- **Proteção de Rotas**: Decorators para páginas protegidas\n- **Gerenciamento de Sessão**: Controle automático de expiração\n- **Segurança**: Hashing de senhas com Werkzeug\n\n### 📊 Dashboard Principal\n- **Métricas em Tempo Real**:\n  - Total de produtos cadastrados\n  - Valor total do estoque\n  - Produtos com estoque baixo\n  - Produtos críticos (< 10 unidades)\n- **Gráficos e Estatísticas**: Visualização interativa dos dados\n- **Alertas**: Notificações de produtos com estoque baixo\n\n### 🛍️ Gestão de Produtos\n- **CRUD Completo**:\n  - ✅ **Create**: Cadastro de novos produtos\n  - 👁️ **Read**: Listagem e visualização detalhada\n  - ✏️ **Update**: Edição de informações\n  - 🗑️ **Delete**: Remoção de produtos\n- **Validações**: Campos obrigatórios e formatos\n- **Busca e Filtros**: Localização rápida de produtos\n- **Paginação**: Navegação eficiente em grandes listas\n\n## 🧪 Sistema de Testes de Performance\n\nO GestokPro inclui um sistema completo de testes de estresse e monitoramento de performance.\n\n### Scripts de Teste\n\n#### `test_stress.py` - Teste Básico\n- **Duração**: 30 segundos\n- **Usuários**: 2 por onda\n- **Endpoints Testados**: Login, Dashboard, Produtos\n- **Métricas**: Tempo de resposta, taxa de sucesso\n\n#### `advanced_stress_test.py` - Teste Avançado\n- **Duração**: 45-60 segundos\n- **Usuários**: Padrões variados (normal, pesado, rápido)\n- **Análise Detalhada**: Percentis, detecção de anomalias\n- **Relatórios**: Markdown com gráficos e recomendações\n\n#### `run_stress_test.py` - Teste Rápido\n- **Propósito**: Execução rápida para validação\n- **Saída**: Resumo direto no terminal\n\n#### `test_menu.py` - Menu Interativo\n- **Interface**: Menu de linha de comando\n- **Opções**: Diferentes tipos de teste\n- **Personalização**: Configuração de parâmetros\n\n### Interface Web de Testes\nAcesse `/teste-estresse` para:\n- 🚀 **Executar Testes**: Botão direto para iniciar\n- 📊 **Ver Histórico**: Lista de todos os testes realizados\n- 📈 **Métricas**: Dashboard com estatísticas\n- 📄 **Relatórios**: Visualização detalhada dos resultados\n\n### Métricas Coletadas\n- **Tempo de Resposta**: Médio, mediana, percentis (P90, P95, P99)\n- **Taxa de Sucesso**: Porcentagem de requests bem-sucedidos\n- **Throughput**: Requests por minuto\n- **Performance por Endpoint**: Análise individual de cada rota\n- **Detecção de Anomalias**: Identificação automática de problemas\n\n## 📖 Como Usar\n\n### 1. Primeiro Acesso\n1. Acesse `http://localhost:5000`\n2. Faça login com as credenciais padrão\n3. Altere a senha do administrador\n4. Explore o dashboard principal\n\n### 2. Cadastrar Produtos\n1. Navegue para \"Produtos\" no menu\n2. Clique em \"Novo Produto\"\n3. Preencha os campos obrigatórios:\n   - SKU (código único)\n   - Nome do produto\n   - Quantidade inicial\n   - Preços de custo e venda\n4. Salve o produto\n\n### 3. Gerenciar Estoque\n1. Na lista de produtos, visualize o status atual\n2. Use os filtros para encontrar produtos específicos\n3. Edite produtos para atualizar quantidades\n4. Monitor alertas de estoque baixo no dashboard\n\n### 4. Executar Testes de Performance\n1. Acesse a aba \"Performance\"\n2. Visualize o histórico de testes anteriores\n3. Clique em \"Executar Teste\" para novo teste\n4. Aguarde a conclusão e analise os resultados\n\n### 5. Monitorar Performance\n- Observe o tempo de resposta no rodapé das páginas\n- Use os relatórios para identificar gargalos\n- Configure alertas para performance crítica\n\n## 🚀 Deploy no GitHub\n\n### 1. Preparar Repositório\n\n```bash\n# Inicializar Git (se não existir)\ngit init\n\n# Adicionar todos os arquivos\ngit add .\n\n# Primeiro commit\ngit commit -m \"Initial commit: GestokPro v1.0\"\n\n# Conectar ao GitHub\ngit remote add origin https://github.com/seu-usuario/gestokpro.git\ngit branch -M main\ngit push -u origin main\n```\n\n### 2. Configurar GitHub Actions (CI/CD)\n\nCrie `.github/workflows/deploy.yml`:\n\n```yaml\nname: Deploy GestokPro\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    services:\n      postgres:\n        image: postgres:13\n        env:\n          POSTGRES_PASSWORD: postgres\n          POSTGRES_DB: gestokpro_test\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Set up Python\n      uses: actions/setup-python@v3\n      with:\n        python-version: '3.9'\n    \n    - name: Install dependencies\n      run: |\n        pip install -r requirements.txt\n    \n    - name: Run tests\n      run: |\n        python -m pytest tests/ -v\n      env:\n        DATABASE_URL: postgresql://postgres:postgres@localhost/gestokpro_test\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n    - name: Deploy to production\n      run: |\n        echo \"Deploy steps here\"\n```\n\n### 3. Configurar Secrets\n\nNo GitHub, vá em Settings > Secrets e adicione:\n- `DATABASE_URL`: URL do banco de produção\n- `SESSION_SECRET`: Chave secreta da sessão\n\n### 4. Documentar no README\n\nAtualize as instruções de instalação e deploy no README.md\n\n### 5. Criar Releases\n\n```bash\n# Criar tag de versão\ngit tag -a v1.0.0 -m \"GestokPro v1.0.0\"\ngit push origin v1.0.0\n```\n\n### 6. Deploy em Plataformas\n\n#### Replit\n- Conecte seu repositório GitHub ao Replit\n- Configure as variáveis de ambiente\n- Use o botão \"Deploy\" do Replit\n\n#### Heroku\n```bash\n# Instalar Heroku CLI\nheroku create gestokpro-app\n\n# Configurar banco\nheroku addons:create heroku-postgresql:hobby-dev\n\n# Deploy\ngit push heroku main\n```\n\n#### Railway/Render\n- Conecte o repositório GitHub\n- Configure variáveis de ambiente\n- Deploy automático a cada push\n\n## 🔗 API Endpoints\n\n### Autenticação\n- `GET /` - Página inicial (redireciona para dashboard se logado)\n- `GET /login` - Página de login\n- `POST /login` - Processar login\n- `GET /logout` - Fazer logout\n\n### Dashboard\n- `GET /dashboard` - Dashboard principal com métricas\n\n### Produtos\n- `GET /produtos` - Lista todos os produtos\n- `GET /produtos/novo` - Formulário de novo produto\n- `POST /produtos/novo` - Criar novo produto\n- `GET /produtos/<id>/editar` - Formulário de edição\n- `POST /produtos/<id>/editar` - Atualizar produto\n- `POST /produtos/<id>/deletar` - Deletar produto\n\n### Testes de Performance\n- `GET /teste-estresse` - Interface web de testes\n- `POST /executar-teste` - Executar novo teste de estresse\n\n### Monitoramento\n- Todas as rotas incluem monitoramento automático de tempo de resposta\n- Métricas exibidas no rodapé das páginas\n\n## 🤝 Contribuição\n\n### Como Contribuir\n\n1. **Fork** o repositório\n2. **Crie** uma branch para sua feature (`git checkout -b feature/nova-feature`)\n3. **Commit** suas mudanças (`git commit -am 'Add nova feature'`)\n4. **Push** para a branch (`git push origin feature/nova-feature`)\n5. **Abra** um Pull Request\n\n### Padrões de Código\n\n- **Python**: Siga PEP 8\n- **HTML/CSS**: Indentação de 2 espaços\n- **JavaScript**: Use ES6+\n- **Commits**: Use Conventional Commits\n\n### Testes\n\nExecute os testes antes de abrir PR:\n\n```bash\n# Testes unitários\npython -m pytest tests/\n\n# Testes de integração\npython -m pytest tests/integration/\n\n# Testes de stress\npython run_stress_test.py\n```\n\n## 📝 Licença\n\nEste projeto está licenciado sob a MIT License - veja o arquivo [LICENSE](LICENSE) para detalhes.\n\n## 📞 Suporte\n\n- **Documentação**: Este README.md\n- **Issues**: Use o GitHub Issues para reportar bugs\n- **Discussões**: GitHub Discussions para dúvidas\n- **Email**: contato@gestokpro.com\n\n---\n\n**GestokPro** - Sistema de Gestão de Estoque Inteligente 🚀","size_bytes":15946},"app.py":{"content":"import os\nimport time\nimport logging\nfrom datetime import datetime\nfrom flask import Flask, render_template, request, redirect, url_for, flash, g\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager, login_user, logout_user, login_required, current_user\nfrom werkzeug.security import check_password_hash\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nfrom sqlalchemy.orm import DeclarativeBase\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\n\nclass Base(DeclarativeBase):\n    pass\n\n# Initialize extensions\ndb = SQLAlchemy(model_class=Base)\nlogin_manager = LoginManager()\n\n# Create Flask app\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\", \"dev-secret-key-change-in-production\")\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n\n# Configure PostgreSQL database\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = os.environ.get(\"DATABASE_URL\")\napp.config[\"SQLALCHEMY_TRACK_MODIFICATIONS\"] = False\napp.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n    \"pool_recycle\": 300,\n    \"pool_pre_ping\": True,\n}\n\n# Initialize extensions with app\ndb.init_app(app)\nlogin_manager.init_app(app)\nlogin_manager.login_view = 'login'\nlogin_manager.login_message = 'Por favor, faça login para acessar esta página.'\n\n# Import models after db initialization\nfrom models import Usuario, Produto\nfrom forms import LoginForm, ProdutoForm\n\n@login_manager.user_loader\ndef load_user(user_id):\n    return Usuario.query.get(int(user_id))\n\n# Performance monitoring\n@app.before_request\ndef before_request_func():\n    g.start_time = time.time()\n\n@app.after_request\ndef after_request_func(response):\n    diff_ms = round((time.time() - g.start_time) * 1000, 2)\n    response.headers['X-Response-Time'] = f'{diff_ms}ms'\n    return response\n\n@app.context_processor\ndef inject_performance():\n    if hasattr(g, 'start_time'):\n        response_time_ms = round((time.time() - g.start_time) * 1000, 2)\n    else:\n        response_time_ms = 0\n    return {'response_time_ms': response_time_ms}\n\n# Routes\n@app.route('/')\ndef index():\n    if current_user.is_authenticated:\n        return redirect(url_for('dashboard'))\n    return redirect(url_for('login'))\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if current_user.is_authenticated:\n        return redirect(url_for('dashboard'))\n    \n    form = LoginForm()\n    if form.validate_on_submit():\n        user = Usuario.query.filter_by(email=form.email.data).first()\n        if user and user.check_password(form.password.data):\n            login_user(user, remember=form.remember_me.data)\n            next_page = request.args.get('next')\n            if not next_page or not next_page.startswith('/'):\n                next_page = url_for('dashboard')\n            return redirect(next_page)\n        flash('Email ou senha inválidos.', 'error')\n    \n    return render_template('login.html', form=form)\n\n@app.route('/logout')\n@login_required\ndef logout():\n    logout_user()\n    flash('Você foi desconectado com sucesso.', 'info')\n    return redirect(url_for('login'))\n\n@app.route('/dashboard')\n@login_required\ndef dashboard():\n    # Calculate metrics\n    total_produtos = Produto.query.count()\n    total_estoque = db.session.query(db.func.sum(Produto.quantidade)).scalar() or 0\n    valor_total_estoque = db.session.query(\n        db.func.sum(Produto.quantidade * Produto.preco_venda)\n    ).scalar() or 0\n    \n    produtos_baixo_estoque = Produto.query.filter(Produto.quantidade <= 5).count()\n    \n    return render_template('dashboard.html', \n                         total_produtos=total_produtos,\n                         total_estoque=total_estoque,\n                         valor_total_estoque=valor_total_estoque,\n                         produtos_baixo_estoque=produtos_baixo_estoque)\n\n@app.route('/produtos')\n@login_required\ndef produtos():\n    page = request.args.get('page', 1, type=int)\n    search = request.args.get('search', '', type=str)\n    \n    query = Produto.query\n    if search:\n        query = query.filter(\n            db.or_(\n                Produto.nome.contains(search),\n                Produto.sku.contains(search),\n                Produto.descricao.contains(search)\n            )\n        )\n    \n    produtos = query.paginate(\n        page=page, per_page=10, error_out=False\n    )\n    \n    return render_template('produtos.html', produtos=produtos, search=search)\n\n@app.route('/produtos/novo', methods=['GET', 'POST'])\n@login_required\ndef produto_novo():\n    form = ProdutoForm()\n    if form.validate_on_submit():\n        produto = Produto(\n            nome=form.nome.data,\n            sku=form.sku.data,\n            descricao=form.descricao.data,\n            quantidade=form.quantidade.data,\n            preco_venda=form.preco_venda.data\n        )\n        db.session.add(produto)\n        db.session.commit()\n        flash('Produto criado com sucesso!', 'success')\n        return redirect(url_for('produtos'))\n    \n    return render_template('produto_form.html', form=form, title='Novo Produto')\n\n@app.route('/produtos/editar/<int:id>', methods=['GET', 'POST'])\n@login_required\ndef produto_editar(id):\n    produto = Produto.query.get_or_404(id)\n    form = ProdutoForm(obj=produto)\n    \n    if form.validate_on_submit():\n        form.populate_obj(produto)\n        db.session.commit()\n        flash('Produto atualizado com sucesso!', 'success')\n        return redirect(url_for('produtos'))\n    \n    return render_template('produto_form.html', form=form, title='Editar Produto', produto=produto)\n\n@app.route('/produtos/excluir/<int:id>', methods=['POST'])\n@login_required\ndef produto_excluir(id):\n    produto = Produto.query.get_or_404(id)\n    db.session.delete(produto)\n    db.session.commit()\n    flash('Produto excluído com sucesso!', 'success')\n    return redirect(url_for('produtos'))\n\n@app.route('/produtos/movimentar/<int:id>', methods=['POST'])\n@login_required\ndef produto_movimentar(id):\n    produto = Produto.query.get_or_404(id)\n    quantidade = request.form.get('quantidade', type=int)\n    \n    if quantidade is None:\n        flash('Quantidade inválida.', 'error')\n        return redirect(url_for('produtos'))\n    \n    nova_quantidade = produto.quantidade + quantidade\n    \n    if nova_quantidade < 0:\n        flash('Estoque insuficiente para esta operação.', 'error')\n        return redirect(url_for('produtos'))\n    \n    produto.quantidade = nova_quantidade\n    db.session.commit()\n    \n    operacao = \"entrada\" if quantidade > 0 else \"saída\"\n    flash(f'Movimentação de {operacao} realizada com sucesso!', 'success')\n    return redirect(url_for('produtos'))\n\n@app.route('/teste-estresse')\n@login_required\ndef teste_estresse():\n    \"\"\"Página para visualizar e executar testes de estresse\"\"\"\n    import glob\n    import os\n    \n    # Busca relatórios existentes\n    basic_reports = glob.glob(\"stress_test_report_*.md\")\n    advanced_reports = glob.glob(\"advanced_stress_report_*.md\")\n    \n    all_reports = []\n    \n    for report_file in basic_reports + advanced_reports:\n        try:\n            stats = os.stat(report_file)\n            created_time = datetime.fromtimestamp(stats.st_mtime)\n            \n            # Lê algumas métricas básicas do relatório\n            with open(report_file, 'r', encoding='utf-8') as f:\n                content = f.read()\n                \n            # Extrai métricas básicas do conteúdo\n            import re\n            # Busca pelos padrões dos relatórios básicos e avançados\n            total_requests = re.search(r'- \\*\\*Total de Requests:\\*\\*\\s*(\\d+)', content)\n            success_rate = re.search(r'- \\*\\*Taxa de Sucesso:\\*\\*\\s*([\\d.]+)%', content)\n            avg_time = re.search(r'- \\*\\*Média:\\*\\*\\s*([\\d.]+)\\s*ms', content)\n            \n            # Se não encontrou no padrão básico, tenta padrão avançado\n            if not avg_time:\n                avg_time = re.search(r'- \\*\\*Tempo de Resposta Médio:\\*\\*\\s*([\\d.]+)\\s*ms', content)\n            \n            report_type = \"Avançado\" if \"advanced\" in report_file else \"Básico\"\n            \n            all_reports.append({\n                'filename': report_file,\n                'type': report_type,\n                'created': created_time.strftime('%d/%m/%Y %H:%M'),\n                'total_requests': total_requests.group(1) if total_requests else 'N/A',\n                'success_rate': success_rate.group(1) if success_rate else 'N/A',\n                'avg_time': avg_time.group(1) if avg_time else 'N/A'\n            })\n        except:\n            continue\n    \n    # Ordena por data de criação (mais recente primeiro)\n    all_reports.sort(key=lambda x: x['created'], reverse=True)\n    \n    return render_template('teste_estresse.html', reports=all_reports)\n\n@app.route('/executar-teste-estresse', methods=['POST'])\n@login_required\ndef executar_teste_estresse():\n    \"\"\"Executa um teste de estresse via web\"\"\"\n    test_type = request.form.get('test_type', 'basic')\n    \n    # Aqui normalmente executaríamos o teste em background\n    # Por simplicidade, vamos apenas simular\n    flash('Teste de estresse iniciado! Verifique os logs do servidor.', 'info')\n    return redirect(url_for('teste_estresse'))\n\n# Create tables\nwith app.app_context():\n    db.create_all()\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)\n","size_bytes":9286},"forms.py":{"content":"from flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, BooleanField, IntegerField, DecimalField, TextAreaField\nfrom wtforms.validators import DataRequired, Email, Length, NumberRange, ValidationError\nfrom models import Produto\n\nclass LoginForm(FlaskForm):\n    email = StringField('Email', validators=[\n        DataRequired(message='Email é obrigatório'),\n        Email(message='Email inválido')\n    ])\n    password = PasswordField('Senha', validators=[\n        DataRequired(message='Senha é obrigatória')\n    ])\n    remember_me = BooleanField('Lembrar de mim')\n\nclass ProdutoForm(FlaskForm):\n    nome = StringField('Nome', validators=[\n        DataRequired(message='Nome é obrigatório'),\n        Length(min=2, max=100, message='Nome deve ter entre 2 e 100 caracteres')\n    ])\n    sku = StringField('SKU', validators=[\n        DataRequired(message='SKU é obrigatório'),\n        Length(min=2, max=50, message='SKU deve ter entre 2 e 50 caracteres')\n    ])\n    descricao = TextAreaField('Descrição', validators=[\n        Length(max=500, message='Descrição deve ter no máximo 500 caracteres')\n    ])\n    quantidade = IntegerField('Quantidade', validators=[\n        DataRequired(message='Quantidade é obrigatória'),\n        NumberRange(min=0, message='Quantidade deve ser maior ou igual a 0')\n    ])\n    preco_venda = DecimalField('Preço de Venda', validators=[\n        DataRequired(message='Preço de venda é obrigatório'),\n        NumberRange(min=0.01, message='Preço deve ser maior que 0')\n    ], places=2)\n    \n    def __init__(self, produto_id=None, *args, **kwargs):\n        super(ProdutoForm, self).__init__(*args, **kwargs)\n        self.produto_id = produto_id\n    \n    def validate_sku(self, sku):\n        produto = Produto.query.filter_by(sku=sku.data).first()\n        if produto:\n            if self.produto_id is None or produto.id != self.produto_id:\n                raise ValidationError('SKU já existe. Use um SKU único.')\n","size_bytes":1980},"init_db.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nScript para inicializar o banco de dados com dados de exemplo.\nExecute este script para recriar o banco de dados com dados iniciais.\n\"\"\"\n\nimport os\nimport sys\nfrom decimal import Decimal\n\n# Add current directory to path to import our modules\nsys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n\nfrom app import app, db\nfrom models import Usuario, Produto\n\ndef init_database():\n    \"\"\"Initialize database with sample data\"\"\"\n    print(\"Inicializando banco de dados...\")\n    \n    with app.app_context():\n        # Drop all tables and recreate\n        print(\"Removendo tabelas existentes...\")\n        db.drop_all()\n        \n        print(\"Criando novas tabelas...\")\n        db.create_all()\n        \n        # Create admin user\n        print(\"Criando usuário administrador...\")\n        admin = Usuario(\n            email='admin@gestokpro.com',\n            is_admin=True\n        )\n        admin.set_password('admin')\n        db.session.add(admin)\n        \n        # Create sample products\n        print(\"Criando produtos de exemplo...\")\n        produtos_exemplo = [\n            {\n                'nome': 'Notebook Dell Inspiron 15',\n                'sku': 'DELL-INS-15-001',\n                'descricao': 'Notebook Dell Inspiron 15 com processador Intel Core i5, 8GB RAM, SSD 256GB',\n                'quantidade': 25,\n                'preco_venda': Decimal('2499.99')\n            },\n            {\n                'nome': 'Mouse Logitech MX Master 3',\n                'sku': 'LOG-MX3-001',\n                'descricao': 'Mouse sem fio ergonômico com sensor de alta precisão e bateria recarregável',\n                'quantidade': 50,\n                'preco_venda': Decimal('349.90')\n            },\n            {\n                'nome': 'Teclado Mecânico Corsair K95',\n                'sku': 'COR-K95-RGB',\n                'descricao': 'Teclado mecânico gamer com switches Cherry MX e iluminação RGB personalizada',\n                'quantidade': 15,\n                'preco_venda': Decimal('899.99')\n            },\n            {\n                'nome': 'Monitor LG UltraWide 29\"',\n                'sku': 'LG-UW29-001',\n                'descricao': 'Monitor ultrawide 29 polegadas, resolução 2560x1080, ideal para produtividade',\n                'quantidade': 8,\n                'preco_venda': Decimal('1299.00')\n            },\n            {\n                'nome': 'SSD Samsung 970 EVO 1TB',\n                'sku': 'SAM-970EVO-1TB',\n                'descricao': 'SSD NVMe M.2 de 1TB com velocidades de leitura até 3.500 MB/s',\n                'quantidade': 30,\n                'preco_venda': Decimal('599.99')\n            },\n            {\n                'nome': 'Webcam Logitech C920',\n                'sku': 'LOG-C920-HD',\n                'descricao': 'Webcam Full HD 1080p com microfone integrado e correção automática de luz',\n                'quantidade': 12,\n                'preco_venda': Decimal('289.90')\n            },\n            {\n                'nome': 'Headset HyperX Cloud II',\n                'sku': 'HYX-CLD2-001',\n                'descricao': 'Headset gamer com som surround 7.1 virtual e microfone com cancelamento de ruído',\n                'quantidade': 20,\n                'preco_venda': Decimal('399.99')\n            },\n            {\n                'nome': 'Cabo HDMI 2.1 - 2m',\n                'sku': 'HDMI-21-2M',\n                'descricao': 'Cabo HDMI 2.1 de alta velocidade, suporta 4K@120Hz e 8K@60Hz',\n                'quantidade': 100,\n                'preco_venda': Decimal('49.90')\n            },\n            {\n                'nome': 'Hub USB-C 7 em 1',\n                'sku': 'HUB-USBC-7IN1',\n                'descricao': 'Hub USB-C com 7 portas: HDMI, USB 3.0, USB-C, leitor de cartão SD/microSD',\n                'quantidade': 35,\n                'preco_venda': Decimal('199.99')\n            },\n            {\n                'nome': 'Suporte para Notebook',\n                'sku': 'SUP-BOOK-ADJ',\n                'descricao': 'Suporte ergonômico ajustável para notebook, melhora postura e ventilação',\n                'quantidade': 18,\n                'preco_venda': Decimal('129.90')\n            }\n        ]\n        \n        for produto_data in produtos_exemplo:\n            produto = Produto(**produto_data)\n            db.session.add(produto)\n        \n        # Commit all changes\n        db.session.commit()\n        \n        print(\"✅ Banco de dados inicializado com sucesso!\")\n        print(\"\\n📊 Dados criados:\")\n        print(\"👤 Usuário administrador:\")\n        print(\"   Email: admin@gestokpro.com\")\n        print(\"   Senha: admin\")\n        print(f\"\\n📦 {len(produtos_exemplo)} produtos de exemplo criados\")\n        print(\"\\n🚀 Você pode agora executar a aplicação com: python app.py\")\n\nif __name__ == '__main__':\n    init_database()\n","size_bytes":4842},"main.py":{"content":"from app import app\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)\n","size_bytes":99},"models.py":{"content":"from flask_sqlalchemy import SQLAlchemy\nfrom flask_login import UserMixin\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom app import db\n\nclass Usuario(UserMixin, db.Model):\n    __tablename__ = 'usuarios'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    email = db.Column(db.String(120), unique=True, nullable=False, index=True)\n    senha_hash = db.Column(db.String(256), nullable=False)\n    is_admin = db.Column(db.Boolean, default=False, nullable=False)\n    \n    def set_password(self, password):\n        \"\"\"Hash and set password\"\"\"\n        self.senha_hash = generate_password_hash(password)\n    \n    def check_password(self, password):\n        \"\"\"Check if provided password matches hash\"\"\"\n        return check_password_hash(self.senha_hash, password)\n    \n    def __repr__(self):\n        return f'<Usuario {self.email}>'\n\nclass Produto(db.Model):\n    __tablename__ = 'produtos'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    nome = db.Column(db.String(100), nullable=False)\n    sku = db.Column(db.String(50), unique=True, nullable=False, index=True)\n    descricao = db.Column(db.Text)\n    quantidade = db.Column(db.Integer, nullable=False, default=0)\n    preco_venda = db.Column(db.Numeric(10, 2), nullable=False)\n    \n    def __repr__(self):\n        return f'<Produto {self.nome}>'\n    \n    @property\n    def valor_total_estoque(self):\n        \"\"\"Calculate total stock value for this product\"\"\"\n        return float(self.quantidade * self.preco_venda)\n    \n    @property\n    def status_estoque(self):\n        \"\"\"Return stock status\"\"\"\n        if self.quantidade == 0:\n            return 'Sem estoque'\n        elif self.quantidade <= 5:\n            return 'Estoque baixo'\n        else:\n            return 'Em estoque'\n","size_bytes":1772},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.2.0\",\n    \"flask-login>=0.6.3\",\n    \"flask>=3.1.1\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"flask-wtf>=1.2.2\",\n    \"wtforms>=3.2.1\",\n    \"werkzeug>=3.1.3\",\n    \"sqlalchemy>=2.0.43\",\n    \"aiohttp>=3.12.15\",\n]\n","size_bytes":425},"replit.md":{"content":"# Overview\n\nGestokPro is a Flask-based inventory management system designed for small to medium businesses. The application provides a web interface for managing product catalogs, tracking stock levels, and monitoring inventory metrics. Built with Python Flask, it offers user authentication, product CRUD operations, and a dashboard for inventory analytics. The system includes an advanced performance testing suite with automated stress testing and detailed reporting capabilities. The system is localized in Portuguese (Brazilian) and focuses on simplicity and ease of use for inventory management tasks.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Architecture\n- **Template Engine**: Jinja2 with Flask's built-in templating system\n- **UI Framework**: Tailwind CSS for responsive design and modern styling\n- **Icons**: Font Awesome for consistent iconography\n- **Architecture Pattern**: Server-side rendered templates with minimal JavaScript\n- **Responsive Design**: Mobile-first approach with responsive grid layouts\n\n## Backend Architecture\n- **Web Framework**: Flask with Blueprint-style organization (though not explicitly using blueprints)\n- **Application Structure**: Monolithic Flask application with separation of concerns\n- **Forms**: WTForms with Flask-WTF for form handling and validation\n- **Authentication**: Flask-Login for session management and user authentication\n- **Password Security**: Werkzeug's security utilities for password hashing\n- **Request Handling**: Standard Flask routing with decorators for authentication\n\n## Data Storage\n- **Database**: PostgreSQL for production deployment with connection pooling\n- **ORM**: SQLAlchemy with Flask-SQLAlchemy integration\n- **Database Schema**: Two main entities - Users (usuarios) and Products (produtos)\n- **Connection Management**: Connection pooling with automatic reconnection and health checks\n- **Migration Strategy**: Manual database initialization script (init_db.py)\n\n## Authentication & Authorization\n- **User Management**: Email-based authentication with password hashing\n- **Session Management**: Flask-Login handles user sessions\n- **Role-Based Access**: Admin flag for user permissions\n- **Security**: CSRF protection via Flask-WTF forms\n- **Password Policy**: Basic password requirements with secure hashing\n\n## Application Configuration\n- **Environment Variables**: Session secrets and database configuration via environment variables\n- **Proxy Support**: ProxyFix middleware for deployment behind reverse proxies\n- **Development Mode**: Debug mode enabled for development environment\n- **Static Assets**: Standard Flask static file serving\n- **Performance Monitoring**: Built-in request timing and context processor for real-time metrics\n\n## Performance Testing System\n- **Web Interface**: `/teste-estresse` route for visual test management and reporting\n- **Command Line Tools**: Multiple test scripts for different scenarios\n- **Automated Reporting**: Markdown reports with detailed performance analysis\n- **Test Types**: Basic (30s), Advanced (45s with mixed load), Intensive (60-90s)\n- **Metrics Collection**: Response times, throughput, success rates, percentiles, anomaly detection\n- **User Simulation**: Normal, heavy, and fast user behavior patterns\n\n## Data Models\n- **Usuario Model**: User accounts with email, password hash, and admin privileges\n- **Produto Model**: Product catalog with SKU, name, description, quantity, and pricing\n- **Business Logic**: Built-in methods for stock calculations and status determination\n\n# External Dependencies\n\n## Core Framework Dependencies\n- **Flask**: Web application framework and routing\n- **Flask-SQLAlchemy**: Database ORM and connection management\n- **Flask-Login**: User authentication and session management\n- **Flask-WTF**: Form handling and CSRF protection\n- **WTForms**: Form validation and rendering\n- **Werkzeug**: WSGI utilities and security functions\n\n## Frontend Dependencies\n- **Tailwind CSS**: Utility-first CSS framework (CDN)\n- **Font Awesome**: Icon library (CDN)\n\n## Performance Testing Dependencies  \n- **aiohttp**: Async HTTP client for stress testing\n- **asyncio**: Asynchronous programming for concurrent user simulation\n- **statistics**: Mathematical statistics for performance analysis\n\n## Database Dependencies\n- **PostgreSQL**: Production database with connection pooling\n- **SQLAlchemy**: Database abstraction layer\n- **psycopg2-binary**: PostgreSQL adapter for Python\n\n## Development Tools\n- **Python Standard Library**: Logging, os, time, threading, glob modules for application functionality\n\n## Deployment Considerations\n- **WSGI Server**: Compatible with any WSGI server (Gunicorn, uWSGI)\n- **Static File Serving**: Can be handled by web server or Flask in development\n- **Database Migration**: Manual initialization script provided\n- **Environment Configuration**: Supports environment-based configuration","size_bytes":4950},"docs/ARCHITECTURE.md":{"content":"# 🏗️ Arquitetura do Sistema - GestokPro\n\n## 📊 Visão Geral da Arquitetura\n\nO GestokPro é construído com uma arquitetura monolítica moderna, otimizada para simplicidade e performance, seguindo os princípios de separação de responsabilidades e escalabilidade horizontal.\n\n```\n┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐\n│   Frontend      │    │    Backend      │    │   Database      │\n│                 │    │                 │    │                 │\n│ • Tailwind CSS  │◄──►│ • Flask 2.3+    │◄──►│ • PostgreSQL    │\n│ • Jinja2        │    │ • SQLAlchemy    │    │ • Connection    │\n│ • Font Awesome  │    │ • Flask-Login   │    │   Pooling       │\n│ • Responsive    │    │ • WTForms       │    │ • ACID          │\n└─────────────────┘    └─────────────────┘    └─────────────────┘\n```\n\n## 🎯 Princípios Arquiteturais\n\n### 1. **Simplicidade em Primeiro Lugar**\n- Monólito bem estruturado vs microserviços desnecessários\n- Stack única (Python) reduz complexidade\n- Configuração mínima para deploy rápido\n\n### 2. **Separação de Responsabilidades**\n```\napp.py      → Controle de rotas e lógica de aplicação\nmodels.py   → Modelos de dados e regras de negócio  \nforms.py    → Validação e processamento de formulários\ntemplates/  → Apresentação e interface do usuário\n```\n\n### 3. **Performance por Design**\n- Connection pooling no banco\n- Middleware de monitoramento integrado\n- Sistema de testes de stress automatizado\n- Queries otimizadas com SQLAlchemy\n\n### 4. **Segurança Integrada**\n- Autenticação com Flask-Login\n- Proteção CSRF em todos os formulários\n- Hash seguro de senhas com Werkzeug\n- Validação de entrada em todas as rotas\n\n## 🔧 Componentes Principais\n\n### **Camada de Apresentação (Frontend)**\n\n**Tecnologias:**\n- Jinja2 para templating server-side\n- Tailwind CSS para styling responsivo\n- Font Awesome para iconografia consistente\n\n**Responsabilidades:**\n- Renderização de templates dinâmicos\n- Formulários interativos com validação\n- Interface responsiva para mobile/desktop\n- Feedback visual de operações\n\n### **Camada de Aplicação (Backend)**\n\n**Estrutura MVC Simplificada:**\n```python\n# Modelo (models.py)\nclass Produto(db.Model):\n    # Entidades de negócio\n    # Validações de domínio\n    # Métodos de cálculo\n\n# Visão (templates/)\n# Templates Jinja2 com lógica de apresentação\n\n# Controlador (app.py)\n@app.route('/produtos')\ndef listar_produtos():\n    # Lógica de controle\n    # Orquestração de serviços\n    # Renderização de resposta\n```\n\n**Módulos Especializados:**\n- `forms.py`: Validação e processamento de entrada\n- `init_db.py`: Migração e seed de dados\n- Testes de performance: Sistema completo de monitoramento\n\n### **Camada de Dados (Database)**\n\n**Modelo Relacional:**\n```sql\nusuarios\n├── id (PK)\n├── email (UNIQUE)\n├── senha_hash\n├── admin (BOOLEAN)\n└── data_criacao\n\nprodutos\n├── id (PK)\n├── sku (UNIQUE)\n├── nome\n├── descricao\n├── quantidade\n├── preco_custo\n├── preco_venda\n├── categoria\n├── data_criacao\n└── data_atualizacao\n```\n\n**Características:**\n- PostgreSQL para ACID e escalabilidade\n- Connection pooling para performance\n- Índices otimizados para consultas frequentes\n- Constraints de integridade referencial\n\n## ⚡ Fluxo de Dados\n\n### **Fluxo de Requisição Típico:**\n\n```\n1. Requisição HTTP → Flask Router\n2. Middleware de Timing → Captura métricas\n3. Autenticação → Flask-Login validation\n4. Validação → WTForms processing\n5. Modelo → SQLAlchemy ORM\n6. Banco → PostgreSQL query\n7. Resposta → Jinja2 template\n8. Frontend → Tailwind CSS styling\n```\n\n### **Exemplo: Cadastro de Produto**\n\n```python\n# 1. Rota recebe requisição\n@app.route('/produtos/novo', methods=['GET', 'POST'])\n@login_required\ndef novo_produto():\n    # 2. Instancia formulário\n    form = ProdutoForm()\n    \n    # 3. Validação de dados\n    if form.validate_on_submit():\n        # 4. Criar modelo\n        produto = Produto(\n            sku=form.sku.data,\n            nome=form.nome.data,\n            # ... outros campos\n        )\n        \n        # 5. Persistir no banco\n        db.session.add(produto)\n        db.session.commit()\n        \n        # 6. Resposta de sucesso\n        flash('Produto cadastrado com sucesso!')\n        return redirect(url_for('produtos'))\n    \n    # 7. Renderizar template\n    return render_template('produto_form.html', form=form)\n```\n\n## 🧪 Sistema de Performance\n\n### **Arquitetura de Monitoramento**\n\n```\n┌─────────────────┐\n│  Web Interface  │ ← Interface visual para testes\n├─────────────────┤\n│  Test Scripts   │ ← Múltiplos tipos de teste\n├─────────────────┤\n│  Async Engine   │ ← aiohttp para concorrência\n├─────────────────┤\n│  Metrics Collector │ ← Coleta de métricas\n├─────────────────┤\n│  Report Generator │ ← Análise e relatórios\n└─────────────────┘\n```\n\n### **Tipos de Teste Implementados:**\n\n1. **Teste Básico (30s)**: Validação rápida\n2. **Teste Avançado (45s)**: Análise detalhada com percentis\n3. **Teste Intensivo (60-90s)**: Stress test completo\n4. **Teste Personalizado**: Via menu interativo\n\n### **Métricas Coletadas:**\n\n- **Performance**: Tempo médio, mediana, P90, P95, P99\n- **Disponibilidade**: Taxa de sucesso, falhas\n- **Capacidade**: Throughput, requests/minuto\n- **Qualidade**: Detecção de anomalias, padrões\n\n## 🔒 Segurança\n\n### **Camadas de Segurança:**\n\n1. **Autenticação**: Flask-Login com sessões seguras\n2. **Autorização**: Decorators `@login_required`\n3. **Validação**: WTForms com sanitização\n4. **CSRF**: Proteção automática em formulários\n5. **Senhas**: Hash com salt usando Werkzeug\n6. **Headers**: ProxyFix para HTTPS correto\n\n### **Práticas de Segurança:**\n\n```python\n# Hash seguro de senhas\nsenha_hash = generate_password_hash(senha)\n\n# Validação de entrada\nclass ProdutoForm(FlaskForm):\n    sku = StringField('SKU', validators=[\n        DataRequired(),\n        Length(min=3, max=20)\n    ])\n\n# Proteção de rota\n@app.route('/admin')\n@login_required\ndef admin_only():\n    if not current_user.admin:\n        abort(403)\n```\n\n## 📈 Escalabilidade\n\n### **Estratégias Implementadas:**\n\n1. **Database Connection Pooling**\n```python\napp.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n    \"pool_recycle\": 300,\n    \"pool_pre_ping\": True,\n}\n```\n\n2. **Template Caching**: Jinja2 otimizado\n3. **Static File Serving**: CDN-ready\n4. **Lazy Loading**: Paginação em listas grandes\n\n### **Pontos de Escala Horizontal:**\n\n- **Web Layer**: Múltiplas instâncias Flask\n- **Database**: Read replicas, sharding\n- **Static Assets**: CDN distribution\n- **Session Store**: Redis/Memcached\n\n## 🚀 Deploy e DevOps\n\n### **Ambientes Suportados:**\n\n1. **Desenvolvimento**: SQLite + Flask dev server\n2. **Staging**: PostgreSQL + Gunicorn\n3. **Produção**: PostgreSQL + Gunicorn + Nginx\n\n### **Pipeline de Deploy:**\n\n```yaml\n# GitHub Actions\nBuild → Test → Security Scan → Deploy\n  ↓       ↓         ↓           ↓\nDocker  Pytest   Bandit    Replit/Heroku\n```\n\n### **Monitoramento em Produção:**\n\n- **Health Checks**: `/health` endpoint\n- **Metrics**: Tempo de resposta em tempo real\n- **Logs**: Structured logging com níveis\n- **Alerts**: Performance degradation detection\n\n## 📊 Métricas e KPIs\n\n### **Performance KPIs:**\n\n- **Tempo de Resposta**: < 500ms para 95% das requests\n- **Disponibilidade**: > 99.5% uptime\n- **Throughput**: > 100 requests/segundo\n- **Error Rate**: < 0.1% de falhas\n\n### **Métricas de Negócio:**\n\n- Produtos cadastrados\n- Operações de estoque\n- Usuários ativos\n- Taxa de utilização de funcionalidades\n\n### **Dashboard de Monitoramento:**\n\nO sistema inclui dashboard em tempo real com:\n- Métricas de performance no rodapé\n- Alertas de estoque baixo\n- Estatísticas de uso do sistema\n- Histórico de testes de performance\n\n---\n\n## 🔮 Roadmap Técnico\n\n### **Versão 2.0 (Futuro):**\n- API REST completa\n- Sistema de relatórios avançados\n- Integração com sistemas externos\n- Mobile app com React Native\n- Machine learning para previsão de estoque\n\n### **Melhorias Contínuas:**\n- Otimização de queries\n- Cache distribuído\n- Testes automatizados expandidos\n- Documentação interativa\n- Observabilidade avançada\n\n---\n\n**Esta arquitetura foi projetada para crescer com seu negócio, mantendo simplicidade e performance.**","size_bytes":9000},"docs/CONTRIBUTING.md":{"content":"# 🤝 Guia de Contribuição - GestokPro\n\nObrigado por seu interesse em contribuir com o GestokPro! Este guia vai te ajudar a começar.\n\n## 📋 Como Contribuir\n\n### 1. Preparação\n```bash\n# Fork o repositório no GitHub\n# Clone seu fork\ngit clone https://github.com/seu-usuario/gestokpro.git\ncd gestokpro\n\n# Adicione o repositório original como upstream\ngit remote add upstream https://github.com/autor-original/gestokpro.git\n```\n\n### 2. Configuração do Ambiente\n```bash\n# Criar ambiente virtual\npython -m venv venv\nsource venv/bin/activate  # Linux/Mac\n\n# Instalar dependências de desenvolvimento\npip install -r requirements.txt\npip install pytest pytest-cov black flake8 pre-commit\n\n# Instalar hooks pre-commit\npre-commit install\n```\n\n### 3. Criação de Feature\n```bash\n# Criar nova branch\ngit checkout -b feature/nova-funcionalidade\n\n# Fazer suas modificações\n# ... código ...\n\n# Testar suas mudanças\npython -m pytest tests/\npython run_stress_test.py\n\n# Commit com mensagem descritiva\ngit add .\ngit commit -m \"feat: adiciona funcionalidade X\"\n\n# Push para seu fork\ngit push origin feature/nova-funcionalidade\n```\n\n### 4. Pull Request\n1. Abra um Pull Request no GitHub\n2. Descreva as mudanças claramente\n3. Referencie issues relacionadas\n4. Aguarde review e feedback\n\n## 🎯 Tipos de Contribuição\n\n### 🐛 Correção de Bugs\n- Reporte bugs via GitHub Issues\n- Inclua passos para reproduzir\n- Descreva comportamento esperado vs atual\n- Adicione capturas de tela se relevante\n\n### ✨ Novas Funcionalidades\n- Discuta a ideia primeiro em uma Issue\n- Implemente seguindo os padrões existentes\n- Adicione testes para nova funcionalidade\n- Atualize documentação se necessário\n\n### 📚 Documentação\n- Melhore README.md\n- Adicione comentários no código\n- Crie tutoriais e guias\n- Traduza documentação\n\n### 🧪 Testes\n- Adicione testes unitários\n- Melhore cobertura de testes\n- Crie testes de integração\n- Otimize testes de performance\n\n## 📝 Padrões de Código\n\n### Python (PEP 8)\n```python\n# Bom ✅\ndef calcular_estoque_total(produtos):\n    \"\"\"Calcula o valor total do estoque.\"\"\"\n    total = 0\n    for produto in produtos:\n        total += produto.quantidade * produto.preco_custo\n    return total\n\n# Evitar ❌\ndef calc_estoque(prods):\n    t=0\n    for p in prods:t+=p.qtd*p.preco\n    return t\n```\n\n### HTML/Jinja2\n```html\n<!-- Bom ✅ -->\n<div class=\"product-card\">\n  <h3 class=\"product-title\">{{ produto.nome }}</h3>\n  <p class=\"product-price\">R$ {{ produto.preco_venda }}</p>\n</div>\n\n<!-- Evitar ❌ -->\n<div class=\"pc\"><h3>{{produto.nome}}</h3><p>R${{produto.preco_venda}}</p></div>\n```\n\n### Mensagens de Commit\nUse Conventional Commits:\n```bash\nfeat: adiciona filtro de produtos por categoria\nfix: corrige cálculo de margem de lucro\ndocs: atualiza README com instruções de deploy\ntest: adiciona testes para modelo Usuario\nrefactor: reorganiza estrutura de templates\nstyle: aplica formatação PEP 8\n```\n\n## 🧪 Executando Testes\n\n### Testes Básicos\n```bash\n# Todos os testes\npython -m pytest\n\n# Com cobertura\npython -m pytest --cov=. --cov-report=html\n\n# Testes específicos\npython -m pytest tests/test_models.py\npython -m pytest tests/test_routes.py -v\n```\n\n### Testes de Performance\n```bash\n# Teste rápido\npython run_stress_test.py\n\n# Teste completo\npython advanced_stress_test.py\n\n# Menu interativo\npython test_menu.py\n```\n\n### Linting e Formatação\n```bash\n# Verificar estilo\nflake8 .\n\n# Formatar código\nblack .\n\n# Verificar imports\nisort . --check-only\n```\n\n## 🏗️ Estrutura de Desenvolvimento\n\n### Adicionando Nova Rota\n1. **Definir rota em `app.py`**:\n```python\n@app.route('/nova-rota')\n@login_required\ndef nova_funcionalidade():\n    return render_template('nova_template.html')\n```\n\n2. **Criar template em `templates/`**:\n```html\n{% extends \"base.html\" %}\n{% block title %}Nova Funcionalidade{% endblock %}\n{% block content %}\n<!-- Conteúdo aqui -->\n{% endblock %}\n```\n\n3. **Adicionar ao menu** em `base.html`\n4. **Criar testes** em `tests/`\n5. **Atualizar documentação**\n\n### Adicionando Nova Entidade\n1. **Definir modelo em `models.py`**:\n```python\nclass NovaEntidade(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    nome = db.Column(db.String(100), nullable=False)\n    # ... outros campos\n```\n\n2. **Criar formulário em `forms.py`**:\n```python\nclass NovaEntidadeForm(FlaskForm):\n    nome = StringField('Nome', validators=[DataRequired()])\n    # ... outros campos\n    submit = SubmitField('Salvar')\n```\n\n3. **Implementar CRUD completo**\n4. **Criar testes de modelo**\n5. **Atualizar init_db.py se necessário**\n\n## 📊 Monitoramento e Debugging\n\n### Logs de Desenvolvimento\n```python\nimport logging\n\n# Configurar logging detalhado\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\n# Usar em suas funções\nlogger = logging.getLogger(__name__)\nlogger.debug(f\"Processando produto: {produto.nome}\")\n```\n\n### Profile de Performance\n```python\nfrom werkzeug.middleware.profiler import ProfilerMiddleware\n\n# Adicionar ao app em desenvolvimento\nif app.debug:\n    app.wsgi_app = ProfilerMiddleware(app.wsgi_app)\n```\n\n## 🚀 Deploy e Testes\n\n### Testando Deploy Local\n```bash\n# Produção local com Gunicorn\ngunicorn --bind 0.0.0.0:5000 --workers 4 main:app\n\n# Testar todos os endpoints\ncurl http://localhost:5000/\ncurl http://localhost:5000/dashboard\ncurl http://localhost:5000/produtos\n```\n\n### Preparando para Deploy\n1. ✅ Todos os testes passando\n2. ✅ Cobertura de testes > 80%\n3. ✅ Linting sem erros\n4. ✅ Performance satisfatória\n5. ✅ Documentação atualizada\n\n## 🔍 Checklist de Pull Request\n\nAntes de enviar PR, verifique:\n\n- [ ] Código segue padrões do projeto\n- [ ] Testes adicionados e passando\n- [ ] Documentação atualizada\n- [ ] Commits seguem Conventional Commits\n- [ ] Branch atualizada com main\n- [ ] PR tem descrição clara\n- [ ] Issues relacionadas linkadas\n\n## 📞 Ajuda e Suporte\n\n### Canais de Comunicação\n- **Issues**: Para bugs e feature requests\n- **Discussions**: Para dúvidas e ideias\n- **Email**: contato@gestokpro.com\n\n### Mentoria para Novos Contribuidores\n- Marque issues como `good first issue`\n- Peça ajuda em issues complexas\n- Participe das discussions\n- Contribua com documentação primeiro\n\n### Recursos Úteis\n- [Flask Documentation](https://flask.palletsprojects.com/)\n- [SQLAlchemy Docs](https://docs.sqlalchemy.org/)\n- [Tailwind CSS](https://tailwindcss.com/docs)\n- [Python PEP 8](https://pep8.org/)\n\n---\n\n**🙏 Obrigado por contribuir com o GestokPro!**\n\nSua contribuição ajuda a tornar o sistema melhor para todos os usuários.","size_bytes":6628},"docs/INSTALL.md":{"content":"# 🚀 Guia de Instalação Rápida - GestokPro\n\n## 📋 Instalação em 5 Minutos\n\n### Pré-requisitos\n- Python 3.8+\n- PostgreSQL 13+\n- Git\n\n### 1. Clone e Configure\n\n```bash\n# Clone o repositório\ngit clone https://github.com/seu-usuario/gestokpro.git\ncd gestokpro\n\n# Criar ambiente virtual\npython -m venv venv\nsource venv/bin/activate  # Linux/Mac\n# ou\nvenv\\Scripts\\activate     # Windows\n\n# Instalar dependências\npip install flask flask-sqlalchemy flask-login flask-wtf wtforms\npip install werkzeug psycopg2-binary gunicorn aiohttp email-validator\n```\n\n### 2. Configurar Banco de Dados\n\n```bash\n# PostgreSQL (Ubuntu/Debian)\nsudo apt update\nsudo apt install postgresql\n\n# Criar banco\nsudo -u postgres createdb gestokpro\n\n# Configurar variáveis (criar arquivo .env)\necho \"DATABASE_URL=postgresql://postgres:senha@localhost/gestokpro\" > .env\necho \"SESSION_SECRET=minha-chave-super-secreta-123\" >> .env\n```\n\n### 3. Inicializar e Executar\n\n```bash\n# Inicializar banco de dados\npython init_db.py\n\n# Executar aplicação\npython app.py\n```\n\n### 4. Acessar Sistema\n\n- URL: `http://localhost:5000`\n- Login: `admin@gestokpro.com`\n- Senha: `admin`\n\n## 🔧 Configuração Detalhada\n\n### Variáveis de Ambiente\n\nCrie arquivo `.env` na raiz do projeto:\n\n```env\n# Banco de Dados\nDATABASE_URL=postgresql://usuario:senha@localhost:5432/gestokpro\n\n# Segurança\nSESSION_SECRET=sua-chave-secreta-super-complexa\n\n# Opcional: Configurações de desenvolvimento\nFLASK_ENV=development\nFLASK_DEBUG=1\n```\n\n### PostgreSQL - Configuração Completa\n\n```bash\n# Instalar PostgreSQL\nsudo apt install postgresql postgresql-contrib\n\n# Acessar console PostgreSQL\nsudo -u postgres psql\n\n# Criar usuário e banco\nCREATE USER gestokpro_user WITH PASSWORD 'senha_forte';\nCREATE DATABASE gestokpro OWNER gestokpro_user;\nGRANT ALL PRIVILEGES ON DATABASE gestokpro TO gestokpro_user;\n\\q\n```\n\n### Estrutura de Pastas Necessárias\n\n```\ngestokpro/\n├── instance/          # Criada automaticamente\n├── static/           # Arquivos estáticos (opcional)\n├── templates/        # Templates HTML\n└── reports/          # Relatórios de teste (criada automaticamente)\n```\n\n## 🐳 Docker (Opcional)\n\n### Dockerfile\n\n```dockerfile\nFROM python:3.9-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\n\nCOPY . .\n\nEXPOSE 5000\n\nCMD [\"gunicorn\", \"--bind\", \"0.0.0.0:5000\", \"main:app\"]\n```\n\n### docker-compose.yml\n\n```yaml\nversion: '3.8'\n\nservices:\n  web:\n    build: .\n    ports:\n      - \"5000:5000\"\n    environment:\n      - DATABASE_URL=postgresql://gestokpro:password@db:5432/gestokpro\n      - SESSION_SECRET=your-secret-key\n    depends_on:\n      - db\n    volumes:\n      - .:/app\n\n  db:\n    image: postgres:13\n    environment:\n      - POSTGRES_DB=gestokpro\n      - POSTGRES_USER=gestokpro\n      - POSTGRES_PASSWORD=password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n\nvolumes:\n  postgres_data:\n```\n\nExecutar com Docker:\n```bash\ndocker-compose up -d\n```\n\n## ⚡ Deploy Rápido\n\n### Replit\n1. Importe repositório do GitHub\n2. Configure variáveis de ambiente no Secrets\n3. Execute `python init_db.py`\n4. Clique em \"Run\"\n\n### Heroku\n```bash\nheroku create gestokpro-app\nheroku addons:create heroku-postgresql:hobby-dev\ngit push heroku main\nheroku run python init_db.py\n```\n\n### Railway\n1. Conecte repositório GitHub\n2. Adicione PostgreSQL\n3. Configure variáveis de ambiente\n4. Deploy automático\n\n## 🧪 Validar Instalação\n\n### 1. Executar Teste Básico\n```bash\npython run_stress_test.py\n```\n\n### 2. Verificar Endpoints\n- Dashboard: `http://localhost:5000/dashboard`\n- Produtos: `http://localhost:5000/produtos`\n- Performance: `http://localhost:5000/teste-estresse`\n\n### 3. Logs de Debug\nVerificar logs no terminal para confirmar:\n- ✅ Conexão com banco de dados\n- ✅ Criação de tabelas\n- ✅ Login de usuário\n- ✅ Carregamento de produtos\n\n## 🔍 Solução de Problemas\n\n### Erro de Banco de Dados\n```bash\n# Verificar se PostgreSQL está rodando\nsudo systemctl status postgresql\n\n# Reiniciar se necessário\nsudo systemctl restart postgresql\n\n# Testar conexão\npsql -U gestokpro_user -d gestokpro -h localhost\n```\n\n### Erro de Dependências\n```bash\n# Atualizar pip\npip install --upgrade pip\n\n# Reinstalar dependências\npip uninstall flask flask-sqlalchemy flask-login\npip install flask flask-sqlalchemy flask-login\n```\n\n### Erro de Permissões\n```bash\n# Linux: dar permissão aos scripts\nchmod +x *.py\n\n# Windows: executar como administrador\n```\n\n### Porta Ocupada\n```bash\n# Verificar processos na porta 5000\nlsof -i :5000\n\n# Matar processo se necessário\nkill -9 PID\n```\n\n## 📞 Ajuda\n\nSe encontrar problemas:\n\n1. ✅ Verifique se todos os pré-requisitos estão instalados\n2. ✅ Confirme se o PostgreSQL está rodando\n3. ✅ Valide as variáveis de ambiente\n4. ✅ Execute `python init_db.py` novamente\n5. ✅ Consulte os logs de erro no terminal\n\n---\n\n**🎉 Instalação concluída! O GestokPro está pronto para uso.**","size_bytes":4982},"stress_testing/advanced_stress_test.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSistema Avançado de Teste de Estresse para GestokPro\nInclui testes mais sofisticados e relatórios com gráficos\n\"\"\"\n\nimport asyncio\nimport aiohttp\nimport time\nimport json\nimport random\nimport statistics\nfrom datetime import datetime, timedelta\nfrom concurrent.futures import ThreadPoolExecutor\nimport threading\nimport os\nimport sys\n\n# Adiciona o diretório atual ao path\nsys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n\nfrom test_stress import GestokProStressTester\n\nclass AdvancedGestokProTester(GestokProStressTester):\n    def __init__(self, base_url=\"http://localhost:5000\"):\n        super().__init__(base_url)\n        self.memory_snapshots = []\n        self.cpu_usage = []\n        self.concurrent_users = []\n        \n    async def simulate_realistic_user(self, session_id, behavior_type=\"normal\"):\n        \"\"\"Simula comportamento mais realista de usuário\"\"\"\n        async with aiohttp.ClientSession() as session:\n            # Login\n            login_success = await self.login_user(session)\n            if not login_success:\n                return\n                \n            if behavior_type == \"heavy\":\n                # Usuário pesado - faz muitas operações\n                operations = [\n                    ('/dashboard', 'GET', 'Dashboard'),\n                    ('/produtos', 'GET', 'Lista Produtos'),\n                    ('/produtos?search=notebook', 'GET', 'Busca Notebook'),\n                    ('/produtos?search=mouse', 'GET', 'Busca Mouse'),\n                    ('/produtos?page=1', 'GET', 'Página 1'),\n                    ('/produtos?page=2', 'GET', 'Página 2'),\n                    ('/produtos/novo', 'GET', 'Novo Produto'),\n                    ('/produtos', 'GET', 'Lista Produtos 2'),\n                    ('/dashboard', 'GET', 'Dashboard 2'),\n                ]\n                delay_between_ops = 0.1\n                \n            elif behavior_type == \"fast\":\n                # Usuário rápido - navega rapidamente\n                operations = [\n                    ('/dashboard', 'GET', 'Dashboard'),\n                    ('/produtos', 'GET', 'Lista Produtos'),\n                    ('/produtos/novo', 'GET', 'Novo Produto'),\n                ]\n                delay_between_ops = 0.05\n                \n            else:  # normal\n                # Usuário normal\n                operations = [\n                    ('/dashboard', 'GET', 'Dashboard'),\n                    ('/produtos', 'GET', 'Lista Produtos'),\n                    ('/produtos?search=' + random.choice(['notebook', 'mouse', 'monitor']), 'GET', 'Busca'),\n                    ('/produtos?page=1', 'GET', 'Paginação'),\n                    ('/produtos/novo', 'GET', 'Formulário'),\n                ]\n                delay_between_ops = 0.2\n            \n            # Executa operações\n            for endpoint, method, description in operations:\n                await self.test_endpoint(\n                    session, method, endpoint, \n                    description=f\"{description} - {behavior_type.title()} User {session_id}\"\n                )\n                await asyncio.sleep(delay_between_ops)\n    \n    async def run_mixed_load_test(self, duration_seconds=60):\n        \"\"\"Executa teste com diferentes tipos de carga\"\"\"\n        print(f\"🚀 Iniciando teste de carga mista...\")\n        print(f\"📊 Duração: {duration_seconds}s\")\n        print(\"-\" * 60)\n        \n        start_time = time.time()\n        wave = 1\n        \n        while time.time() - start_time < duration_seconds:\n            # Mistura diferentes tipos de usuários\n            user_types = ['normal'] * 2 + ['heavy'] * 1 + ['fast'] * 1\n            random.shuffle(user_types)\n            \n            print(f\"🌊 Onda {wave} - Usuários: {', '.join(user_types)}\")\n            \n            # Cria tasks para diferentes tipos de usuários\n            tasks = []\n            for i, user_type in enumerate(user_types):\n                session_id = f\"{wave}-{i+1}\"\n                task = asyncio.create_task(\n                    self.simulate_realistic_user(session_id, user_type)\n                )\n                tasks.append(task)\n            \n            # Executa usuários simultaneamente\n            await asyncio.gather(*tasks, return_exceptions=True)\n            \n            wave += 1\n            await asyncio.sleep(random.uniform(1, 3))  # Pausa variável entre ondas\n            \n        print(f\"✅ Teste de carga mista concluído!\")\n        print(f\"📈 Total de requests: {len(self.results)}\")\n    \n    def generate_advanced_report(self):\n        \"\"\"Gera relatório avançado com mais análises\"\"\"\n        if not self.results:\n            print(\"❌ Nenhum resultado disponível\")\n            return\n            \n        # Análise temporal\n        results_by_time = {}\n        for result in self.results:\n            timestamp = datetime.fromisoformat(result['timestamp'])\n            time_bucket = timestamp.replace(second=0, microsecond=0)  # Agrupa por minuto\n            \n            if time_bucket not in results_by_time:\n                results_by_time[time_bucket] = []\n            results_by_time[time_bucket].append(result['response_time_ms'])\n        \n        # Calcula throughput por minuto\n        throughput_data = []\n        for time_bucket, response_times in sorted(results_by_time.items()):\n            throughput_data.append({\n                'time': time_bucket.strftime('%H:%M'),\n                'requests_per_minute': len(response_times),\n                'avg_response_time': statistics.mean(response_times),\n                'max_response_time': max(response_times)\n            })\n        \n        # Análise de percentis mais detalhada\n        response_times = [r['response_time_ms'] for r in self.results]\n        response_times.sort()\n        \n        percentiles = {}\n        for p in [10, 25, 50, 75, 80, 85, 90, 95, 99, 99.9]:\n            if len(response_times) > 0:\n                index = int(len(response_times) * (p / 100.0))\n                if index >= len(response_times):\n                    index = len(response_times) - 1\n                percentiles[f'P{p}'] = response_times[index]\n        \n        # Detecção de anomalias\n        mean_time = statistics.mean(response_times)\n        std_dev = statistics.stdev(response_times) if len(response_times) > 1 else 0\n        threshold = mean_time + (2 * std_dev)  # 2 desvios padrão\n        \n        anomalies = [r for r in self.results if r['response_time_ms'] > threshold]\n        \n        # Gera relatório\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        report_filename = f\"advanced_stress_report_{timestamp}.md\"\n        \n        report_content = f\"\"\"# Relatório Avançado de Teste de Estresse - GestokPro\n\n**Data/Hora:** {datetime.now().strftime(\"%d/%m/%Y às %H:%M:%S\")}  \n**URL Testada:** {self.base_url}  \n**Tipo de Teste:** Carga Mista (Usuários Normal, Pesado e Rápido)\n\n## 📊 Resumo Executivo\n\n### Indicadores Chave de Performance (KPIs)\n- **Total de Requests:** {len(self.results)}\n- **Taxa de Sucesso:** {len([r for r in self.results if r['success']])/len(self.results)*100:.1f}%\n- **Tempo de Resposta Médio:** {statistics.mean(response_times):.2f} ms\n- **Throughput Médio:** {len(self.results) / ((max([datetime.fromisoformat(r['timestamp']) for r in self.results]) - min([datetime.fromisoformat(r['timestamp']) for r in self.results])).total_seconds() / 60):.1f} req/min\n\n### Classificação de Performance\n\"\"\"\n        \n        avg_time = statistics.mean(response_times)\n        if avg_time < 200:\n            performance_grade = \"🟢 EXCELENTE\"\n            performance_desc = \"Sistema operando com performance ótima\"\n        elif avg_time < 500:\n            performance_grade = \"🟡 BOM\"\n            performance_desc = \"Performance aceitável, monitoramento recomendado\"\n        elif avg_time < 1000:\n            performance_grade = \"🟠 ATENÇÃO\"\n            performance_desc = \"Performance degradada, otimização necessária\"\n        else:\n            performance_grade = \"🔴 CRÍTICO\"\n            performance_desc = \"Performance inaceitável, ação imediata necessária\"\n            \n        report_content += f\"**Status:** {performance_grade}  \\n**Avaliação:** {performance_desc}\\n\\n\"\n        \n        # Percentis detalhados\n        report_content += f\"\"\"## 📈 Análise de Percentis de Latência\n\n| Percentil | Tempo de Resposta |\n|-----------|-------------------|\n\"\"\"\n        for percentil, valor in percentiles.items():\n            report_content += f\"| {percentil} | {valor:.2f} ms |\\n\"\n        \n        # Throughput por tempo\n        report_content += f\"\"\"\n## ⚡ Análise de Throughput\n\n| Horário | Req/min | Tempo Médio | Tempo Máximo |\n|---------|---------|-------------|--------------|\n\"\"\"\n        for data in throughput_data:\n            report_content += f\"| {data['time']} | {data['requests_per_minute']} | {data['avg_response_time']:.1f} ms | {data['max_response_time']:.1f} ms |\\n\"\n        \n        # Anomalias\n        if anomalies:\n            report_content += f\"\"\"\n## 🚨 Detecção de Anomalias\n\nForam detectados **{len(anomalies)}** requests com tempo de resposta anômalo (>{threshold:.1f} ms):\n\n\"\"\"\n            for anomaly in anomalies[-5:]:  # Últimas 5 anomalias\n                report_content += f\"- {anomaly['endpoint']} - {anomaly['response_time_ms']:.1f} ms ({anomaly['timestamp']})\\n\"\n        \n        # Análise de padrões\n        report_content += f\"\"\"\n## 🔍 Análise de Padrões de Uso\n\n### Endpoints Mais Acessados\n\"\"\"\n        endpoint_counts = {}\n        for result in self.results:\n            endpoint = result['endpoint']\n            endpoint_counts[endpoint] = endpoint_counts.get(endpoint, 0) + 1\n        \n        for endpoint, count in sorted(endpoint_counts.items(), key=lambda x: x[1], reverse=True)[:5]:\n            percentage = (count / len(self.results)) * 100\n            report_content += f\"- **{endpoint}**: {count} requests ({percentage:.1f}%)\\n\"\n        \n        # Recomendações baseadas nos dados\n        report_content += f\"\"\"\n## 💡 Recomendações de Otimização\n\n\"\"\"\n        \n        if avg_time > 1000:\n            report_content += \"### 🔴 Ações Críticas\\n\"\n            report_content += \"- Implementar cache de consultas ao banco de dados\\n\"\n            report_content += \"- Otimizar queries SQL mais lentas\\n\"\n            report_content += \"- Considerar implementar paginação mais eficiente\\n\"\n            report_content += \"- Revisar índices do banco de dados\\n\\n\"\n        \n        if len(anomalies) > len(self.results) * 0.05:  # Mais de 5% de anomalias\n            report_content += \"### 🟠 Estabilidade\\n\"\n            report_content += \"- Investigar picos de latência\\n\"\n            report_content += \"- Implementar circuit breakers\\n\"\n            report_content += \"- Configurar alertas de performance\\n\\n\"\n        \n        # Endpoints que precisam de otimização\n        slow_endpoints = []\n        endpoint_stats = {}\n        for result in self.results:\n            endpoint = result['endpoint']\n            if endpoint not in endpoint_stats:\n                endpoint_stats[endpoint] = []\n            endpoint_stats[endpoint].append(result['response_time_ms'])\n        \n        for endpoint, times in endpoint_stats.items():\n            avg_endpoint_time = statistics.mean(times)\n            if avg_endpoint_time > 500:  # Endpoints com mais de 500ms\n                slow_endpoints.append((endpoint, avg_endpoint_time))\n        \n        if slow_endpoints:\n            report_content += \"### 🔧 Endpoints para Otimização\\n\"\n            for endpoint, avg_time in sorted(slow_endpoints, key=lambda x: x[1], reverse=True):\n                report_content += f\"- **{endpoint}**: {avg_time:.1f} ms médio\\n\"\n        \n        report_content += f\"\"\"\n## 📊 Dados Técnicos Detalhados\n\n### Distribuição de Status Codes\n\"\"\"\n        status_codes = {}\n        for result in self.results:\n            code = result['status_code']\n            status_codes[code] = status_codes.get(code, 0) + 1\n        \n        for code, count in sorted(status_codes.items()):\n            percentage = (count / len(self.results)) * 100\n            report_content += f\"- **{code}**: {count} requests ({percentage:.1f}%)\\n\"\n        \n        report_content += f\"\"\"\n### Métricas de Confiabilidade\n- **MTTR (Mean Time To Respond)**: {statistics.mean(response_times):.2f} ms\n- **Desvio Padrão**: {std_dev:.2f} ms\n- **Coeficiente de Variação**: {(std_dev/statistics.mean(response_times))*100:.1f}%\n- **Requests com Erro**: {len([r for r in self.results if not r['success']])}\n- **Uptime**: {len([r for r in self.results if r['success']])/len(self.results)*100:.2f}%\n\n---\n*Relatório gerado automaticamente pelo Sistema Avançado de Teste de Estresse*  \n*Versão: 2.0 | Data: {datetime.now().strftime(\"%d/%m/%Y %H:%M:%S\")}*\n\"\"\"\n        \n        # Salva o relatório\n        with open(report_filename, 'w', encoding='utf-8') as f:\n            f.write(report_content)\n            \n        print(f\"📄 Relatório avançado salvo: {report_filename}\")\n        \n        # Exibe resumo no console\n        print(\"\\n\" + \"=\"*70)\n        print(\"🎯 RELATÓRIO AVANÇADO DE TESTE DE ESTRESSE\")\n        print(\"=\"*70)\n        print(f\"Status de Performance: {performance_grade}\")\n        print(f\"Total de Requests: {len(self.results)}\")\n        print(f\"Taxa de Sucesso: {len([r for r in self.results if r['success']])/len(self.results)*100:.1f}%\")\n        print(f\"Tempo Médio: {avg_time:.2f} ms\")\n        print(f\"P95: {percentiles.get('P95', 0):.2f} ms\")\n        print(f\"P99: {percentiles.get('P99', 0):.2f} ms\")\n        print(f\"Anomalias Detectadas: {len(anomalies)}\")\n        print(f\"Endpoints Lentos: {len(slow_endpoints)}\")\n        print(\"=\"*70)\n        \n        return report_filename\n\nasync def main():\n    \"\"\"Executa teste avançado\"\"\"\n    print(\"🧪 GestokPro - Sistema Avançado de Teste de Estresse\")\n    print(\"=\" * 60)\n    \n    # Configurações do teste\n    BASE_URL = \"http://localhost:5000\"\n    DURATION = 45  # segundos\n    \n    # Cria testador avançado\n    tester = AdvancedGestokProTester(base_url=BASE_URL)\n    \n    # Executa teste de carga mista\n    await tester.run_mixed_load_test(duration_seconds=DURATION)\n    \n    # Gera relatório avançado\n    report_file = tester.generate_advanced_report()\n    \n    print(f\"\\n🎉 Teste avançado concluído!\")\n    print(f\"📊 Relatório detalhado: {report_file}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":14497},"stress_testing/run_stress_test.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nScript simplificado para executar teste de estresse no GestokPro\n\"\"\"\n\nimport asyncio\nimport sys\nimport os\n\n# Adiciona o diretório atual ao path\nsys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n\nfrom test_stress import GestokProStressTester\n\nasync def run_quick_test():\n    \"\"\"Executa um teste rápido de estresse\"\"\"\n    print(\"🧪 Iniciando teste de estresse do GestokPro...\")\n    \n    # Configurações\n    BASE_URL = \"http://localhost:5000\"\n    DURATION = 30  # 30 segundos\n    USERS_PER_WAVE = 2  # 2 usuários simultâneos por onda\n    \n    # Cria testador\n    tester = GestokProStressTester(base_url=BASE_URL)\n    \n    # Executa teste\n    await tester.run_stress_test(duration_seconds=DURATION, users_per_wave=USERS_PER_WAVE)\n    \n    # Gera relatório\n    report_file = tester.generate_performance_report()\n    \n    print(f\"\\n✅ Teste concluído!\")\n    print(f\"📄 Relatório salvo em: {report_file}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(run_quick_test())","size_bytes":1014},"stress_testing/test_menu.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nMenu interativo para executar diferentes tipos de teste no GestokPro\n\"\"\"\n\nimport asyncio\nimport os\nimport sys\n\ndef show_menu():\n    print(\"\\n🧪 GestokPro - Menu de Testes de Performance\")\n    print(\"=\" * 50)\n    print(\"1. Teste Rápido (30s) - 2 usuários por onda\")\n    print(\"2. Teste Completo (60s) - 3 usuários por onda\") \n    print(\"3. Teste Avançado (45s) - Carga mista com relatório detalhado\")\n    print(\"4. Teste Intenso (90s) - 5 usuários por onda\")\n    print(\"5. Ver último relatório gerado\")\n    print(\"0. Sair\")\n    print(\"-\" * 50)\n\nasync def run_basic_test(duration, users):\n    \"\"\"Executa teste básico\"\"\"\n    from test_stress import GestokProStressTester\n    \n    tester = GestokProStressTester(base_url=\"http://localhost:5000\")\n    await tester.run_stress_test(duration_seconds=duration, users_per_wave=users)\n    return tester.generate_performance_report()\n\nasync def run_advanced_test():\n    \"\"\"Executa teste avançado\"\"\"\n    from advanced_stress_test import AdvancedGestokProTester\n    \n    tester = AdvancedGestokProTester(base_url=\"http://localhost:5000\")\n    await tester.run_mixed_load_test(duration_seconds=45)\n    return tester.generate_advanced_report()\n\ndef show_latest_report():\n    \"\"\"Mostra o último relatório gerado\"\"\"\n    import glob\n    \n    # Busca pelos relatórios mais recentes\n    basic_reports = glob.glob(\"stress_test_report_*.md\")\n    advanced_reports = glob.glob(\"advanced_stress_report_*.md\")\n    \n    all_reports = basic_reports + advanced_reports\n    \n    if not all_reports:\n        print(\"❌ Nenhum relatório encontrado\")\n        return\n    \n    # Ordena por data de modificação\n    all_reports.sort(key=os.path.getmtime, reverse=True)\n    latest_report = all_reports[0]\n    \n    print(f\"\\n📄 Último relatório: {latest_report}\")\n    print(\"-\" * 50)\n    \n    try:\n        with open(latest_report, 'r', encoding='utf-8') as f:\n            content = f.read()\n            # Mostra apenas o resumo (primeiras 50 linhas)\n            lines = content.split('\\n')[:50]\n            print('\\n'.join(lines))\n            \n            if len(content.split('\\n')) > 50:\n                print(\"\\n... (relatório completo no arquivo)\")\n                \n    except Exception as e:\n        print(f\"❌ Erro ao ler relatório: {e}\")\n\nasync def main():\n    \"\"\"Menu principal\"\"\"\n    while True:\n        show_menu()\n        \n        try:\n            choice = input(\"Escolha uma opção: \").strip()\n            \n            if choice == \"0\":\n                print(\"👋 Até logo!\")\n                break\n                \n            elif choice == \"1\":\n                print(\"🚀 Iniciando teste rápido...\")\n                report = await run_basic_test(duration=30, users=2)\n                print(f\"✅ Teste concluído! Relatório: {report}\")\n                \n            elif choice == \"2\":\n                print(\"🚀 Iniciando teste completo...\")\n                report = await run_basic_test(duration=60, users=3)\n                print(f\"✅ Teste concluído! Relatório: {report}\")\n                \n            elif choice == \"3\":\n                print(\"🚀 Iniciando teste avançado com carga mista...\")\n                report = await run_advanced_test()\n                print(f\"✅ Teste avançado concluído! Relatório: {report}\")\n                \n            elif choice == \"4\":\n                print(\"🚀 Iniciando teste intenso...\")\n                report = await run_basic_test(duration=90, users=5)\n                print(f\"✅ Teste intenso concluído! Relatório: {report}\")\n                \n            elif choice == \"5\":\n                show_latest_report()\n                \n            else:\n                print(\"❌ Opção inválida!\")\n                \n            input(\"\\nPressione Enter para continuar...\")\n            \n        except KeyboardInterrupt:\n            print(\"\\n👋 Teste interrompido pelo usuário!\")\n            break\n        except Exception as e:\n            print(f\"❌ Erro: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":4054},"stress_testing/test_stress.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSistema de Teste de Estresse para GestokPro\nSimula múltiplos usuários e operações para testar performance da aplicação.\n\"\"\"\n\nimport asyncio\nimport aiohttp\nimport time\nimport json\nimport random\nimport statistics\nfrom datetime import datetime\nfrom concurrent.futures import ThreadPoolExecutor\nimport threading\n\nclass GestokProStressTester:\n    def __init__(self, base_url=\"http://localhost:5000\", max_concurrent=10):\n        self.base_url = base_url\n        self.max_concurrent = max_concurrent\n        self.results = []\n        self.login_cookies = None\n        self.test_products = []\n        self.lock = threading.Lock()\n        \n    async def get_csrf_token(self, session):\n        \"\"\"Obtém token CSRF da página de login\"\"\"\n        try:\n            async with session.get(f\"{self.base_url}/login\") as response:\n                html = await response.text()\n                # Busca pelo token CSRF no HTML\n                import re\n                match = re.search(r'name=\"csrf_token\"[^>]*value=\"([^\"]*)\"', html)\n                return match.group(1) if match else None\n        except:\n            return None\n\n    async def login_user(self, session):\n        \"\"\"Realiza login na aplicação\"\"\"\n        try:\n            csrf_token = await self.get_csrf_token(session)\n            if not csrf_token:\n                return False\n                \n            login_data = {\n                'email': 'admin@gestokpro.com',\n                'password': 'admin',\n                'csrf_token': csrf_token,\n                'remember_me': False\n            }\n            \n            async with session.post(f\"{self.base_url}/login\", data=login_data) as response:\n                return response.status in [200, 302]  # 302 = redirect após login\n        except:\n            return False\n\n    async def test_endpoint(self, session, method, endpoint, data=None, description=\"\"):\n        \"\"\"Testa um endpoint específico e mede o tempo de resposta\"\"\"\n        start_time = time.time()\n        success = False\n        status_code = 0\n        \n        try:\n            if method.upper() == 'GET':\n                async with session.get(f\"{self.base_url}{endpoint}\") as response:\n                    status_code = response.status\n                    success = 200 <= status_code < 400\n            elif method.upper() == 'POST':\n                async with session.post(f\"{self.base_url}{endpoint}\", data=data) as response:\n                    status_code = response.status\n                    success = 200 <= status_code < 400\n                    \n        except Exception as e:\n            success = False\n            status_code = 0\n            \n        response_time = (time.time() - start_time) * 1000  # em ms\n        \n        result = {\n            'timestamp': datetime.now().isoformat(),\n            'method': method,\n            'endpoint': endpoint,\n            'description': description,\n            'response_time_ms': round(response_time, 2),\n            'status_code': status_code,\n            'success': success\n        }\n        \n        with self.lock:\n            self.results.append(result)\n            \n        return result\n\n    async def simulate_user_session(self, session_id):\n        \"\"\"Simula uma sessão completa de usuário\"\"\"\n        async with aiohttp.ClientSession() as session:\n            # 1. Login\n            login_success = await self.login_user(session)\n            if not login_success:\n                print(f\"❌ Sessão {session_id}: Falha no login\")\n                return\n                \n            print(f\"✅ Sessão {session_id}: Login realizado\")\n            \n            # 2. Acessa dashboard\n            await self.test_endpoint(session, 'GET', '/dashboard', \n                                   description=f\"Dashboard - Sessão {session_id}\")\n            \n            # 3. Lista produtos (múltiplas vezes)\n            for i in range(3):\n                await self.test_endpoint(session, 'GET', '/produtos', \n                                       description=f\"Lista Produtos {i+1} - Sessão {session_id}\")\n                await asyncio.sleep(0.1)  # Pequena pausa entre requests\n            \n            # 4. Busca produtos\n            search_terms = ['notebook', 'mouse', 'teclado', 'monitor']\n            search_term = random.choice(search_terms)\n            await self.test_endpoint(session, 'GET', f'/produtos?search={search_term}', \n                                   description=f\"Busca '{search_term}' - Sessão {session_id}\")\n            \n            # 5. Simula navegação entre páginas\n            for page in range(1, 3):\n                await self.test_endpoint(session, 'GET', f'/produtos?page={page}', \n                                       description=f\"Página {page} - Sessão {session_id}\")\n            \n            # 6. Acessa formulário de novo produto\n            await self.test_endpoint(session, 'GET', '/produtos/novo', \n                                   description=f\"Formulário Novo Produto - Sessão {session_id}\")\n            \n            print(f\"✅ Sessão {session_id}: Completada\")\n\n    async def run_stress_test(self, duration_seconds=60, users_per_wave=5):\n        \"\"\"Executa teste de estresse principal\"\"\"\n        print(f\"🚀 Iniciando teste de estresse...\")\n        print(f\"📊 Duração: {duration_seconds}s | Usuários por onda: {users_per_wave}\")\n        print(f\"🔗 URL: {self.base_url}\")\n        print(\"-\" * 60)\n        \n        start_time = time.time()\n        wave = 1\n        \n        while time.time() - start_time < duration_seconds:\n            print(f\"🌊 Onda {wave} - {users_per_wave} usuários simultâneos\")\n            \n            # Cria tasks para usuários simultâneos\n            tasks = []\n            for user_id in range(users_per_wave):\n                session_id = f\"{wave}-{user_id + 1}\"\n                task = asyncio.create_task(self.simulate_user_session(session_id))\n                tasks.append(task)\n            \n            # Executa todos os usuários da onda simultaneamente\n            await asyncio.gather(*tasks, return_exceptions=True)\n            \n            wave += 1\n            await asyncio.sleep(2)  # Pausa entre ondas\n            \n        print(f\"✅ Teste de estresse concluído!\")\n        print(f\"📈 Total de requests executados: {len(self.results)}\")\n\n    def generate_performance_report(self):\n        \"\"\"Gera relatório detalhado de performance\"\"\"\n        if not self.results:\n            print(\"❌ Nenhum resultado disponível para gerar relatório\")\n            return\n            \n        # Estatísticas gerais\n        response_times = [r['response_time_ms'] for r in self.results]\n        successful_requests = [r for r in self.results if r['success']]\n        failed_requests = [r for r in self.results if not r['success']]\n        \n        # Estatísticas por endpoint\n        endpoints_stats = {}\n        for result in self.results:\n            endpoint = result['endpoint']\n            if endpoint not in endpoints_stats:\n                endpoints_stats[endpoint] = {\n                    'count': 0,\n                    'success_count': 0,\n                    'response_times': [],\n                    'status_codes': []\n                }\n            \n            stats = endpoints_stats[endpoint]\n            stats['count'] += 1\n            if result['success']:\n                stats['success_count'] += 1\n            stats['response_times'].append(result['response_time_ms'])\n            stats['status_codes'].append(result['status_code'])\n        \n        # Gera relatório\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        report_filename = f\"stress_test_report_{timestamp}.md\"\n        \n        report_content = f\"\"\"# Relatório de Teste de Estresse - GestokPro\n\n**Data/Hora:** {datetime.now().strftime(\"%d/%m/%Y às %H:%M:%S\")}  \n**URL Testada:** {self.base_url}  \n**Duração do Teste:** {max([datetime.fromisoformat(r['timestamp']) for r in self.results]) - min([datetime.fromisoformat(r['timestamp']) for r in self.results])}\n\n## 📊 Resumo Geral\n\n- **Total de Requests:** {len(self.results)}\n- **Requests Bem-sucedidos:** {len(successful_requests)} ({len(successful_requests)/len(self.results)*100:.1f}%)\n- **Requests com Falha:** {len(failed_requests)} ({len(failed_requests)/len(self.results)*100:.1f}%)\n- **Taxa de Sucesso:** {len(successful_requests)/len(self.results)*100:.1f}%\n\n## ⚡ Métricas de Performance\n\n### Tempo de Resposta (ms)\n- **Média:** {statistics.mean(response_times):.2f} ms\n- **Mediana:** {statistics.median(response_times):.2f} ms\n- **Mínimo:** {min(response_times):.2f} ms\n- **Máximo:** {max(response_times):.2f} ms\n- **Desvio Padrão:** {statistics.stdev(response_times) if len(response_times) > 1 else 0:.2f} ms\n\n### Percentis\n- **P50 (Mediana):** {statistics.median(response_times):.2f} ms\n- **P90:** {sorted(response_times)[int(len(response_times) * 0.9)]:.2f} ms\n- **P95:** {sorted(response_times)[int(len(response_times) * 0.95)]:.2f} ms\n- **P99:** {sorted(response_times)[int(len(response_times) * 0.99)]:.2f} ms\n\n## 🎯 Performance por Endpoint\n\n\"\"\"\n        \n        for endpoint, stats in sorted(endpoints_stats.items()):\n            avg_response = statistics.mean(stats['response_times'])\n            success_rate = (stats['success_count'] / stats['count']) * 100\n            \n            report_content += f\"\"\"### {endpoint}\n- **Total de Requests:** {stats['count']}\n- **Taxa de Sucesso:** {success_rate:.1f}%\n- **Tempo Médio de Resposta:** {avg_response:.2f} ms\n- **Tempo Mínimo:** {min(stats['response_times']):.2f} ms\n- **Tempo Máximo:** {max(stats['response_times']):.2f} ms\n\n\"\"\"\n        \n        # Análise e recomendações\n        avg_response_time = statistics.mean(response_times)\n        success_rate = len(successful_requests) / len(self.results) * 100\n        \n        report_content += f\"\"\"## 🔍 Análise e Recomendações\n\n### Performance Geral\n\"\"\"\n        \n        if avg_response_time < 100:\n            report_content += \"✅ **Excelente**: Tempo de resposta médio abaixo de 100ms\\n\"\n        elif avg_response_time < 200:\n            report_content += \"🟡 **Bom**: Tempo de resposta médio entre 100-200ms\\n\"\n        elif avg_response_time < 500:\n            report_content += \"🟠 **Aceitável**: Tempo de resposta médio entre 200-500ms\\n\"\n        else:\n            report_content += \"🔴 **Crítico**: Tempo de resposta médio acima de 500ms - otimização necessária\\n\"\n            \n        if success_rate >= 99:\n            report_content += \"✅ **Excelente**: Taxa de sucesso acima de 99%\\n\"\n        elif success_rate >= 95:\n            report_content += \"🟡 **Bom**: Taxa de sucesso entre 95-99%\\n\"\n        else:\n            report_content += \"🔴 **Crítico**: Taxa de sucesso abaixo de 95% - investigação necessária\\n\"\n            \n        # Endpoints mais lentos\n        slow_endpoints = []\n        for endpoint, stats in endpoints_stats.items():\n            avg_time = statistics.mean(stats['response_times'])\n            if avg_time > 200:  # endpoints com mais de 200ms em média\n                slow_endpoints.append((endpoint, avg_time))\n        \n        if slow_endpoints:\n            report_content += f\"\\n### Endpoints que Precisam de Otimização\\n\"\n            for endpoint, avg_time in sorted(slow_endpoints, key=lambda x: x[1], reverse=True):\n                report_content += f\"- **{endpoint}**: {avg_time:.2f} ms médio\\n\"\n        \n        report_content += f\"\"\"\n## 📋 Dados Detalhados\n\n### Últimos 10 Requests\n\"\"\"\n        \n        # Últimos requests\n        recent_requests = sorted(self.results, key=lambda x: x['timestamp'])[-10:]\n        for req in recent_requests:\n            status_icon = \"✅\" if req['success'] else \"❌\"\n            report_content += f\"- {status_icon} {req['method']} {req['endpoint']} - {req['response_time_ms']}ms ({req['status_code']})\\n\"\n        \n        report_content += f\"\"\"\n---\n*Relatório gerado automaticamente pelo Sistema de Teste de Estresse do GestokPro*\n\"\"\"\n        \n        # Salva o relatório\n        with open(report_filename, 'w', encoding='utf-8') as f:\n            f.write(report_content)\n            \n        print(f\"📄 Relatório salvo em: {report_filename}\")\n        \n        # Exibe resumo no console\n        print(\"\\n\" + \"=\"*60)\n        print(\"📊 RESUMO DO TESTE DE ESTRESSE\")\n        print(\"=\"*60)\n        print(f\"Total de Requests: {len(self.results)}\")\n        print(f\"Taxa de Sucesso: {success_rate:.1f}%\")\n        print(f\"Tempo Médio: {avg_response_time:.2f} ms\")\n        print(f\"Tempo Máximo: {max(response_times):.2f} ms\")\n        print(f\"Relatório completo: {report_filename}\")\n        print(\"=\"*60)\n        \n        return report_filename\n\nasync def main():\n    \"\"\"Função principal\"\"\"\n    print(\"🧪 GestokPro - Sistema de Teste de Estresse\")\n    print(\"=\" * 50)\n    \n    # Configurações do teste\n    BASE_URL = \"http://localhost:5000\"\n    DURATION = 30  # segundos\n    USERS_PER_WAVE = 3  # usuários simultâneos por onda\n    \n    # Cria instância do testador\n    tester = GestokProStressTester(base_url=BASE_URL)\n    \n    # Executa teste de estresse\n    await tester.run_stress_test(duration_seconds=DURATION, users_per_wave=USERS_PER_WAVE)\n    \n    # Gera relatório\n    report_file = tester.generate_performance_report()\n    \n    print(f\"\\n🎉 Teste concluído! Verifique o arquivo: {report_file}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":13457},"static/css/styles.css":{"content":"/* Custom styles for GestokPro */\n\n/* Smooth transitions for all interactive elements */\n* {\n    transition: all 0.2s ease-in-out;\n}\n\n/* Custom focus styles */\n.focus\\:ring-blue-500:focus {\n    --tw-ring-color: #3b82f6;\n}\n\n/* Custom button hover effects */\n.btn-hover:hover {\n    transform: translateY(-1px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n}\n\n/* Loading animation for forms */\n.loading {\n    opacity: 0.6;\n    pointer-events: none;\n}\n\n/* Custom table hover effect */\n.table-row:hover {\n    background-color: #f8fafc;\n    transform: scale(1.01);\n}\n\n/* Pagination styles */\n.pagination-active {\n    background-color: #3b82f6;\n    color: white;\n}\n\n/* Alert animations */\n.alert {\n    animation: slideIn 0.3s ease-out;\n}\n\n@keyframes slideIn {\n    from {\n        opacity: 0;\n        transform: translateY(-10px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n/* Custom scrollbar */\n::-webkit-scrollbar {\n    width: 8px;\n    height: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: #f1f5f9;\n}\n\n::-webkit-scrollbar-thumb {\n    background: #cbd5e1;\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: #94a3b8;\n}\n\n/* Form validation styles */\n.is-valid {\n    border-color: #10b981;\n}\n\n.is-invalid {\n    border-color: #ef4444;\n}\n\n/* Performance footer styles */\nfooter {\n    backdrop-filter: blur(10px);\n    background-color: rgba(249, 250, 251, 0.95);\n}\n\n/* Mobile responsive improvements */\n@media (max-width: 640px) {\n    .container {\n        padding-left: 1rem;\n        padding-right: 1rem;\n    }\n    \n    .table-responsive {\n        overflow-x: auto;\n    }\n    \n    .btn-mobile {\n        padding: 0.75rem 1rem;\n        font-size: 0.875rem;\n    }\n}\n\n/* Print styles */\n@media print {\n    .no-print {\n        display: none !important;\n    }\n    \n    body {\n        background: white !important;\n        color: black !important;\n    }\n}\n\n/* High contrast mode support */\n@media (prefers-contrast: high) {\n    .border {\n        border-width: 2px;\n    }\n    \n    .bg-gray-50 {\n        background-color: #ffffff;\n    }\n    \n    .text-gray-600 {\n        color: #000000;\n    }\n}\n\n/* Dark mode support (if needed in future) */\n@media (prefers-color-scheme: dark) {\n    /* Future dark mode styles can be added here */\n}\n\n/* Custom utility classes */\n.shadow-glow {\n    box-shadow: 0 0 20px rgba(59, 130, 246, 0.15);\n}\n\n.gradient-bg {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n}\n\n/* Form input focus improvements */\ninput:focus, textarea:focus, select:focus {\n    outline: none;\n    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\n\n/* Card hover effects */\n.card-hover:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);\n}\n\n/* Status badge animations */\n.status-badge {\n    animation: pulse 2s infinite;\n}\n\n@keyframes pulse {\n    0%, 100% {\n        opacity: 1;\n    }\n    50% {\n        opacity: 0.8;\n    }\n}\n\n/* Loading spinner */\n.spinner {\n    border: 2px solid #f3f4f6;\n    border-top: 2px solid #3b82f6;\n    border-radius: 50%;\n    width: 20px;\n    height: 20px;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Accessibility improvements */\n.sr-only {\n    position: absolute;\n    width: 1px;\n    height: 1px;\n    padding: 0;\n    margin: -1px;\n    overflow: hidden;\n    clip: rect(0, 0, 0, 0);\n    white-space: nowrap;\n    border: 0;\n}\n\n/* Focus visible for keyboard navigation */\n.focus-visible:focus-visible {\n    outline: 2px solid #3b82f6;\n    outline-offset: 2px;\n}\n\n/* Custom grid system for metrics */\n.metrics-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n    gap: 1.5rem;\n}\n\n/* Responsive typography */\n@media (max-width: 768px) {\n    h1 {\n        font-size: 1.5rem;\n    }\n    \n    h2 {\n        font-size: 1.25rem;\n    }\n    \n    .text-3xl {\n        font-size: 1.875rem;\n    }\n}\n","size_bytes":3953}}}